# aptos-zk-soundness-vault

Minimal Aptos Move example of a web3 vault inspired by zk-rollup and privacy projects such as Aztec, Zama and soundness-focused proof systems.

The module demonstrates how an on-chain vault can lock AptosCoin against opaque note commitments. The actual proof verification and encryption happens off-chain, while the Move code enforces basic accounting and event emission on-chain.

Repository contains exactly two files:

1. app.zksound.move – Move module with the vault implementation
2. README.md – this documentation file

---

## Concept

High-level idea:

- Users deposit AptosCoin into a shared vault.
- Each deposit is associated with a commitment, treated as an encrypted or hashed representation of a private note.
- Off-chain proof systems (for example systems inspired by Aztec, Zama FHE or general zk soundness frameworks) can later verify proofs about these notes.
- On-chain, the Move module:
  - Locks coins under the vault account address.
  - Stores lightweight metadata about notes.
  - Emits events so indexers, provers, and off-chain services can track deposits and withdrawals.
- Real zero-knowledge verification is out of scope here; this module focuses on the on-chain accounting pattern that such systems commonly use.

---

## Features

- AptosCoin-based vault with a dedicated admin address.
- Deposit entry function that:
  - Moves AptosCoin from the user to the vault.
  - Creates a new note with a commitment and amount.
  - Emits a DepositEvent for off-chain tracking.
- Withdraw entry function that:
  - Marks a note as spent.
  - Releases AptosCoin to a specified recipient.
  - Emits a WithdrawalEvent.
- Read-only helper functions:
  - get_total_locked: total AptosCoin locked in the vault.
  - get_note_count: how many notes are registered.
- Design shaped by web3 privacy ideas:
  - Commitments can be generated by Aztec-style circuits.
  - Commitments may be encrypted using Zama-style FHE flows.
  - Off-chain logic is expected to guarantee soundness of proofs before calling withdraw.

---

## Prerequisites

You need the following installed and configured:

- Aptos CLI (latest version from the official Aptos documentation).
- Rust toolchain, as required by Aptos CLI.
- A local Aptos testnet or devnet endpoint, or an account on public devnet.
- A Move-compatible editor or IDE is recommended but not required.

Assumptions:

- You already have an Aptos account with some test APT funded on devnet.
- You know your account address and private key and have run basic Aptos CLI commands before.

---

## Repository structure

- app.zksound.move
  - Defines the module 0xc0ffee::zk_soundness_vault.
  - Includes:
    - Vault resource type.
    - Note type for note metadata.
    - Deposit and withdrawal events.
    - Public entry functions to deposit and withdraw.
    - Helper view functions for monitoring vault state.
- README.md
  - Project background and instructions (this file).

---

## Installation

1. Create a new folder for the project:
   - Example: mkdir aptos-zk-soundness-vault and cd into it.

2. Create the standard Aptos Move project layout:
   - Run Aptos CLI to initialize a Move project.
   - Replace the default example module file with app.zksound.move.
   - Ensure the module address in the code matches your chosen publishing address or an alias in Move.toml.

3. Copy the file contents:
   - Create a new file named app.zksound.move in the sources directory.
   - Paste the Move code from app.zksound.move into that file.
   - Create README.md at the repo root and paste this documentation into it.

4. Adjust module address:
   - In app.zksound.move, the module header uses address 0xc0ffee.
   - You can:
     - Use an address alias in Move.toml that maps a named address to your actual account.
     - Or replace 0xc0ffee with your own on-chain account address.

5. Configure Move.toml:
   - Set package name to aptos-zk-soundness-vault (or any name you prefer).
   - Add a named address for the module if you choose to use one.
   - Point sources to the directory where app.zksound.move lives.

---

## Building

To build the project:

1. From the project root, run the Aptos CLI command that compiles the Move package.
2. Ensure there are no compilation errors.
3. If you changed the module address, verify that Move.toml and app.zksound.move are consistent.

Common checks:

- Module address in the code is either:
  - A literal you control, or
  - A named address that matches Move.toml.
- All imports (aptos_framework, aptos_std, std) match your Aptos SDK version.

---

## Testing locally (logical flow)

This minimal example does not define Move unit tests, but you can test the logic by:

1. Publishing the module to devnet.
2. Calling deposit_with_commitment.
3. Calling helper view functions.
4. Calling withdraw_note.

Typical sequence:

1. Publish:
   - Use Aptos CLI to publish the package to devnet from your account.
   - Confirm that the transaction succeeded.

2. Initialize the vault:
   - Call init_module with a signer whose address equals the module address (for example a named address mapped to your admin account).
   - This creates the Vault resource and event handles.

3. Deposit:
   - Call deposit_with_commitment with:
     - commitment: a byte vector representing a hashed or encrypted note.
     - amount: some APT amount that you can afford to lock.
   - The transaction:
     - Moves APT from your signer.
     - Creates a new note.
     - Emits a DepositEvent.

4. Inspect:
   - Call get_total_locked to see how much APT is locked.
   - Call get_note_count to see how many notes exist.

5. Withdraw:
   - Call withdraw_note with:
     - note_id: the id of the note you want to unlock.
     - recipient: address to receive the unlocked APT.
   - The transaction:
     - Marks the note as spent.
     - Decreases total_locked.
     - Transfers APT to recipient.
     - Emits a WithdrawalEvent.

---

## Off-chain integration with web3 privacy projects

This repository only provides the on-chain Move component. To build a full system similar to Aztec, Zama-based FHE stacks, or general soundness-focused zk frameworks, you would integrate as follows:

- Commitment generation:
  - Use an off-chain zk or FHE engine to generate commitments representing private balances or state.
  - For example, circuits that resemble Aztec-style rollups or Zama-style encrypted computation outputs.

- Proof generation:
  - Use an off-chain prover that creates zero-knowledge proofs of correct state transitions.
  - Each proof would show that deposits and withdrawals preserve invariants such as: total locked equals the sum of all unspent notes.

- Proof verification (out-of-scope in this Move module):
  - On-chain verification might involve verifying proof data passed into an entry function.
  - This example assumes verification happens off-chain first, and the Move contract is later called with a note_id that is consistent with the off-chain proof.

- Indexers and relayers:
  - Listen for DepositEvent and WithdrawalEvent logs.
  - Maintain a database of commitments and spent notes.
  - Drive user interfaces that show balances and allow them to request proofs and withdrawals.

---

## Expected result

After successfully deploying and using the module, you should be able to:

- Lock APT in a shared vault controlled by the zk_soundness_vault module.
- Associate each deposit with a commitment that may encode:
  - encrypted balances,
  - privacy-preserving metadata,
  - or zk proof identifiers.
- Use read-only functions to verify:
  - total_locked correctly increases after deposits and decreases after withdrawals,
  - note_count increases as you create new notes.
- Track all vault activity through events:
  - DepositEvent describes new commitments entering the system.
  - WithdrawalEvent describes which note ids were used for withdrawals.

Conceptually, the expected outcome is a stepping stone towards a more mature web3 protocol where:

- Soundness is guaranteed by off-chain zk proofs.
- Privacy is protected by encryption and commitment schemes.
- Move-based smart contracts remain minimal, focused on accounting and event emission.

---

## Notes and limitations

- Security:
  - This is an educational example, not production-ready.
  - There is no on-chain verification of zk proofs.
  - There is no role-based control over who can call withdraw_note beyond simple note ownership.
  - There is no prevention against misuse or reentrancy-like patterns from richer contract compositions.

- Accounting model:
  - Vault stores Note objects in a simple vector.
  - Spent notes remain in the vector but are marked as spent.
  - Real-world designs might:
    - Prune spent notes,
    - Use efficient indexing,
    - Or rely on off-chain databases plus cryptographic accumulators or Merkle trees.

- Compatibility:
  - The module expects Aptos-style standard libraries (aptos_framework and aptos_std).
  - The exact import paths may change as Aptos evolves; adjust imports if your SDK version differs.

- Customization:
  - You can change the admin address, module name, and event schemas.
  - You can add entry functions to:
    - support batched deposits,
    - integrate proof verification,
    - or work with tokens other than AptosCoin.

- Relationship to real projects:
  - Aztec, Zama, and similar projects provide full stacks for zk rollups and FHE-based computation.
  - This repository offers a minimal on-chain pattern you can extend to plug into those systems.
  - The soundness property of your broader protocol will depend on:
    - the correctness of your off-chain circuits,
    - your proof system,
    - and how you wire them into this or similar on-chain logic.

---

## Future extensions

If you want to evolve this repository further, possible directions include:

- Add a Merkle tree or other commitment accumulator on-chain.
- Introduce a dedicated verifier module that checks proof objects.
- Support multiple assets by making the vault generic over coin types.
- Add unit tests for deposit and withdrawal logic.
- Integrate with front-end wallets and dapps that:
  - generate commitments,
  - manage encrypted notes,
  - and interact with this module through Aptos transactions.

This repository is intended as a compact, readable starting point that demonstrates how Move can host a vault whose behavior is influenced by web3 privacy and soundness concepts drawn from projects like Aztec, Zama, and zk proof systems in general.

